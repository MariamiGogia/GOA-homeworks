photo 1
მოცემულია ფუნქცია whatday, რომელიც არგუმენტად იღებს რაიმე რიცხვს. ფუნქციაში არის dictionary, რომლის key არის რიცხვები 1დან 7მდე
და value კვირიდან შაბათამდე, რომ შევამოწმოთ არგუმენტად მოცემული რიცხვი არის თუ არა კვირის რომელიმე დღის შესაბამისი, ამიტომაც
მოცემულია if statement, რომლითაც ვამოწმებთ შემოყვანილი რიცხვი არის თუ არა 1დან 8მდე range-ში და თუ არის გამოგვაქვს ეს კვირის დღე,
თუ არადა გამოგვაქვს, რომ "Wrong, please enter a number between 1 and 7". ამიტომაც როდესაც არგუმენტად მივეცით 5 რიცხვი, ფუნქციამ
გამოიტანა ხუთსაბათი.

photo 2
მოცემულია ფუნქცია distinct, რომელიც არგუმენტად იღებს რაღაც list და დუბლიკატებს შლის, ამიტომაც ფუნქციაში არის ცარიელი listn, სადაც
ვამატებთ მოცემული listდან for loop-ით გადატარებული ისეთ ელემენტებს, რომლებიც listn-ში არ არის ჯერ ჩამატებული. თუ list-ის ელემეტი
არის უკვე listn-ში მაშინ ვტოვებთ მას , ხოლო თუ არ არის ვამატებთ, ბოლოს კი გამოგვაქვს listn.
print(distinct([1,2,2,3,3,4,4,5,6,7,7,7])), ეს რომ იყო მოცემული ფუნქციამ ყველა დუბლიკატი გააქრო და მივიღეთ [1,2,3,4,5,6,7]

photo 3
მოცემულია ფუნქცია position, რომელიც არგუმენტად იღებს ასოს და გამოაქვს მისი რიგის ნომერი ანბანში. ფუნქციაში არის variable alphabet1, 
რომელშიც წერია რიგის მიხედვით ანბანის ასოები, შემდეგ return-ით გამოგვაქვს შემოყვანილი ასოს ნომერი, რომელსაც ვპოულობთ ფუნქცია
find(გვეუბნება მერამდენე ინდექსზე არის alphabet1-ში) და რადგანაც ინდექსის ათვლა იწყება 0დან ამიტომაც 1-ს ვუმატებთ. 
print(position("f")) იქნებოდა პასუხი 6, რადგან ის არის მე5 ინდექსზე და 5-ს დაემატებოდა 1 და მივიღებდით 6-ს.

photo 4
მოცემულია ფუნქცია to_alternating_case, რომელიც არგუმენტად იღებს string-ს და უცვლის ზომას, ანუ თუ ასო მოცემულია uppercase-ით, 
ეგ გადაყავს lower-ში და პირიქით. ამიტომაც ფუნქციაში გვაქვს ცარიელი ცვლადი res, სადაც for loop-ით ვამატებთ ჯერ if statement-ით 
შემოწმებულ შებრუნებულ case-ს, და ბოლოს გამოგვაქვს res ცვლადი.

photo 5
მოცემულია ფუნქცია powers_of_two, რომელიც არგუმენტად იღებს რიცხვს და მას ატარებს for loop-ს, შემდეგ კი მის ცათვლით ყველა რიცხვს
ახარისხებს 2-ზე და გამოაქვს ისინი list-ში. print(powers_of_two(6)) მივიღებთ [1,2,4,8,16,32,64]

photo 6
მოცემულია ფუნქცია domain_name, რომელიც არგუმენტად იღებს ლინკს, რომელიც replace, უკეთებს ცარიელი ""-ით ლინკის დაწყებას, შემდეგ 
წერტილთან split-ს უკეთებს, რომ დარჩეს ორი ნაწილი, პირველი მარტო სახელი და მეორე com... და გამოაქვს ცვლადის მარტო 0
ინდექსზე მყოფი მნიშვნელობა, რომელიც არის ლინკის სათაური. print(domain_name("http://www.codewars.com/kata/)) გამოიტანს, 
მხოლოდ სახელს/სათაურს ანუ codewars

photo 7
მოცემულია ფუნქცია alphanumeric, რომელიც ამოწმებს შესაფერისია თუ არა შეყვანილი password, ამიტომაც ჯერ strip-ს უკეთებს, რომ დარწმუნდეს
მხოლოდ ერთი სიმბოლოს გამეორებით არ შედგება პაროლი, შემდეგ for loop-ით ამოწმებს პაროლის ელემენტი არის თუ არა ასოებში, თუ
არის is_valid= True, თუარადა is_valid= False და წყვეტს კოდის განხილვას, შემდეგ გამოაქვს is_valid.

photo 8
მოცემულია ფუნქცია spin_words, რომელიც არგუმენტად იღებს წინადადებას. შემდეგ ამ წინადადებას შლის სიტყვებად და თუ სიტყვის სიგრძე ტოლია
ან მეტია 5-ზე ატრიალებს და ისე ამატებს listn-ში. მთლიანი წინადადების გადატარების შემდეგ listn-ს join ფუნქციის მეშვეობით აერთებს 
string-ად და ისე გამოაქვს.

photo 9
მოცემულია ფუნქცია duplicate_count, რომელიც არგუმეტად იღებს ტექტს. ფუნქციაში არის ცარიელი ლისტი, შემდეგ ტექტს ატარებს 
for loop-ს და case sensitive რომ გააქროს მთელ ტექტს აქცევს lowercase-ად. ამოწმებს თუ ელემენტის count არის 2 ან 2-ზე მეტი ამ ელემენს
ამატებს ლისტში. შემდეგ ლისტს სვავს set-ში, რომ მხოლოდ ერთ-ერთი დარჩეს და მოცემული რაოდენობა გამოაქვს ანუ გვეუბნება 
რამდენი ელემენტი გამეორდა 2-ჯერ ან მეტჯერ.
print(duplicate_count("Indivisibilities)) გამოიტაბს 2-ს(i,s).